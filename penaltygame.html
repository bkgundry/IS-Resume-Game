<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Penalty Game — Mobile Fixes</title>
<style>
:root{
  --goal-w:175; --goal-h:100; --ball-d:25; --keeper-d:45;
}
html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial;background:#0b1220;color:#eee}
.wrap{display:flex;gap:12px;padding:12px;align-items:flex-start}
.game{position:relative;flex:1;max-width:1100px}
canvas{display:block;border-radius:6px;width:100%;height:auto;background:#000}
.ui{width:260px;min-width:220px}
.panel{background:#071726;padding:12px;border-radius:8px}
h3{margin:6px 0 10px 0;font-weight:600}
.score{font-size:18px;margin-bottom:10px}
.hint{font-size:13px;color:#cfe9ff}

/* touch controls overlay */
.touch-controls{
  position:absolute;
  left:0; right:0; bottom:12px;
  display:flex; justify-content:space-between; pointer-events:none;
  padding:0 12px;
  transition:opacity .12s ease;
}
.touch-controls.hidden{opacity:0;pointer-events:none;visibility:hidden}
.touch-btn{
  pointer-events:auto;
  user-select:none;
  -webkit-user-select:none;
  width:46%;
  max-width:220px;
  min-height:56px;
  display:flex;
  align-items:center;
  justify-content:center;
  background:rgba(11,39,51,0.9);
  border-radius:10px;
  color:#cfe9ff;
  font-weight:700;
  font-size:18px;
  box-shadow:0 6px 18px rgba(0,0,0,0.5);
  border:2px solid rgba(5,47,63,0.6);
  transition:transform .06s ease,opacity .06s;
  touch-action: none;
}
.touch-btn:active{transform:translateY(2px);opacity:.95}
.touch-btn.pressed{background:#ffd54f;color:#072026}

/* responsive: on narrow screens stack UI under game */
@media (max-width:900px){
  .wrap{flex-direction:column;gap:12px}
  .ui{width:100%}
  .game{max-width:100%}
  .touch-controls{bottom:8px}
}
</style>
</head>
<body>
<div class="wrap">
  <div class="game" id="gameWrap">
    <canvas id="c" width="760" height="420"></canvas>

    <!-- touch controls overlay -->
    <div class="touch-controls" id="touchControls" aria-hidden="false">
      <div id="btn-height" class="touch-btn" role="button" aria-pressed="false" tabindex="0">Hold ↑ (Height)</div>
      <div id="btn-lat" class="touch-btn" role="button" aria-pressed="false" tabindex="0">Hold ↓ (Direction)</div>
    </div>
  </div>

  <div class="ui" id="desktopUI">
    <div class="panel">
      <h3>Penalty prototype</h3>
      <div class="score">Current streak: <span id="streak">0</span><br>High score: <span id="high">0</span></div>
      <div class="hint">
        Controls:<br>
        Hold <b>↑</b> to set height (release to lock).<br>
        Hold <b>↓</b> to set lateral (release to lock).<br>
        When both locked the ball will shoot automatically.<br>
        <em>On touch devices: press & hold the on-screen buttons.</em>
      </div>
    </div>
  </div>
</div>

<script>
// -------------------- core constants --------------------
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const LOGICAL_W = 760, LOGICAL_H = 420;
canvas.width = LOGICAL_W;
canvas.height = LOGICAL_H;

let W = LOGICAL_W, H = LOGICAL_H;

const GOAL_W=175, GOAL_H=100, BALL_D=25, KEEPER_D=45;
const R_BALL=BALL_D/2, R_KEEP=KEEPER_D/2;
const goalX=(W-GOAL_W)/2, goalY=60;
const goalLeft=goalX, goalRight=goalX+GOAL_W, goalTop=goalY, goalBottom=goalY+GOAL_H;

const SIX_YARD_HEIGHT = 40;
const BOX18_HEIGHT = 110;
const BOX18_LEFT = goalLeft - 60;
const BOX18_WIDTH = GOAL_W + 120;
const BAR_L_Y = goalBottom + BOX18_HEIGHT + 8;

// vertical bar to left of 18-yard box (we will update x/y in code)
const BAR_V_MARGIN = 6;
const BAR_V_WIDTH = 10;
const BAR_V_X = BOX18_LEFT - BAR_V_WIDTH - BAR_V_MARGIN;
const BAR_V_Y = goalBottom;
const BAR_V_H = BOX18_HEIGHT;

const bar={v:{x:BAR_V_X,y:BAR_V_Y,w:BAR_V_WIDTH,h:BAR_V_H},l:{x:goalX,y:BAR_L_Y,w:GOAL_W,h:10}};

// -------------------- game state --------------------
let ball={x:W/2,y:goalBottom+40+R_BALL,r:R_BALL,vx:0,vy:0,moving:false,target:null};
let keeper={x:W/2,y:goalBottom-R_KEEP,r:R_KEEP,vx:0,vy:0,moving:false,target:null};

let chargingHeight=false, chargingLat=false;
let heightValue=null, latValue=null;
let hvDir=1, lvDir=-1, hvPos=0, lvPos=1;
const OSC_SPEED=0.9;

let streak=0, high=0;
const streakEl=document.getElementById('streak');
const highEl=document.getElementById('high');

// -------------------- util --------------------
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function circlesOverlap(a,b){ const dx=a.x-b.x, dy=a.y-b.y, r=a.r+b.r; return dx*dx+dy*dy<=r*r; }
function mapToGoal(nLat,nHeight){
  const x=goalLeft + nLat*(GOAL_W-BALL_D) + R_BALL;
  const y=goalBottom - nHeight*(GOAL_H-BALL_D) - R_BALL;
  return {x,y};
}
function mapKeeperToGoal(){
  const nLat=Math.random(), nHeight=Math.random();
  const x=goalLeft + nLat*(GOAL_W-KEEPER_D) + R_KEEP;
  const y=goalBottom - nHeight*(GOAL_H-KEEPER_D) - R_KEEP;
  return {x,y};
}

// -------------------- shooting & reset (fixed locking issue) --------------------
function tryShoot(){
  if(heightValue!==null && latValue!==null && !ball.moving){
    // finalize any charging state immediately (prevent stuck state)
    finalizeChargingState();

    ball.target = mapToGoal(latValue, heightValue);
    ball.vx = (ball.target.x - ball.x) / 30;
    ball.vy = (ball.target.y - ball.y) / 30;
    ball.moving = true;

    keeper.target = mapKeeperToGoal();
    keeper.vx = (keeper.target.x - keeper.x) / 30;
    keeper.vy = (keeper.target.y - keeper.y) / 30;
    keeper.moving = true;

    // clear the locked values so bars visually unlock for the next round
    heightValue = null;
    latValue = null;
    // reset osc positions to defaults
    hvPos = 0;
    lvPos = 1;

    // ensure DOM button states get cleared
    clearButtonVisuals();
  }
}

function finalizeChargingState(){
  // clear charging flags (used by both keyboard and touch)
  chargingHeight = false;
  chargingLat = false;
}

// ensure everything is unlocked after each round
function resetPositions(){
  ball.x=W/2; ball.y=goalBottom+40+R_BALL; ball.vx=0; ball.vy=0; ball.moving=false; ball.target=null;
  keeper.x=W/2; keeper.y=goalBottom-R_KEEP; keeper.vx=0; keeper.vy=0; keeper.moving=false; keeper.target=null;

  // unlock and reset bar positions
  finalizeChargingState();
  heightValue = null; latValue = null;
  hvPos = 0; lvPos = 1;

  // clear visuals too
  clearButtonVisuals();
}

// -------------------- input handling (keyboard) --------------------
window.addEventListener('keydown', e=>{
  if(e.repeat) return;
  if(e.key==='ArrowUp') { chargingHeight=true; heightValue=null; updateBtnPressed('height', true); }
  if(e.key==='ArrowDown') { chargingLat=true; latValue=null; lvDir=-1; lvPos=1; updateBtnPressed('lat', true); }
});
window.addEventListener('keyup', e=>{
  if(e.key==='ArrowUp') { chargingHeight=false; heightValue=hvPos; updateBtnPressed('height', false); tryShoot(); }
  if(e.key==='ArrowDown') { chargingLat=false; latValue=lvPos; updateBtnPressed('lat', false); tryShoot(); }
});

// -------------------- drawing (keeps visuals you built earlier) --------------------
// We'll keep these compact — identical visuals as before: crowd, track, field, boxes, keeper, ball
const crowdRects = [];
let CROWD_BOTTOM = 0;
(function generateCrowd(){
  const baseTop = 10; const rowHeight = 14; const cellWidth = 9;
  const cols = Math.ceil(W / cellWidth); const rows = 6;
  for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
    const jitterX=(Math.random()*4-2), x=Math.floor(c*cellWidth+(cellWidth-7)/2+jitterX);
    const jitterY=(Math.random()*4-2), y=Math.floor(10 + r*rowHeight + jitterY);
    const w=7,h=12, base=90+Math.floor(Math.random()*80);
    crowdRects.push({x,y,w,h,base});
  }
  CROWD_BOTTOM = 10 + rows*rowHeight + 2;
})();

function drawBackground(){
  ctx.fillStyle = '#0b1220';
  ctx.fillRect(0,0,W,H);

  // crowd (stationary positions, flicker)
  for(const rect of crowdRects){
    const flicker = 0.25 + Math.random()*0.5;
    const col = Math.max(0, Math.min(255, rect.base + Math.floor((Math.random()-0.5)*20)));
    ctx.fillStyle = `rgba(${col},${col},${col},${flicker})`;
    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
  }

  // brick-red track between crowd and field
  const trackTop = CROWD_BOTTOM;
  const grassTop = goalBottom;
  if (grassTop > trackTop){
    const trackGrad = ctx.createLinearGradient(0, trackTop, 0, grassTop);
    trackGrad.addColorStop(0,'#8b2e2e'); trackGrad.addColorStop(1,'#b23a2f');
    ctx.fillStyle = trackGrad; ctx.fillRect(0, trackTop, W, grassTop - trackTop);
    ctx.save(); ctx.globalAlpha = 0.06;
    for(let i=0;i<6;i++){ const y = trackTop + (i/6)*(grassTop - trackTop); ctx.fillRect(0,y,W,2); }
    ctx.restore();
  }

  // grass
  const grassY = goalBottom;
  const grad = ctx.createLinearGradient(0, grassY, 0, H);
  grad.addColorStop(0,'#2c7a32'); grad.addColorStop(1,'#1e5c24');
  ctx.fillStyle = grad; ctx.fillRect(0, grassY, W, H - grassY);

  // stripes
  ctx.save(); ctx.globalAlpha = 0.06;
  const stripeCount = 6;
  for(let i=0;i<stripeCount;i++){
    const y = grassY + (i/stripeCount) * (H - grassY);
    ctx.fillRect(0, y, W, 6);
  }
  ctx.restore();

  // field lines
  drawFieldLines();
}

function drawFieldLines(){
  ctx.save(); ctx.strokeStyle='white'; ctx.lineWidth=3;
  const sixWidth = GOAL_W * 0.5; const sixX = goalLeft + (GOAL_W - sixWidth)/2; const sixY = goalBottom;
  ctx.strokeRect(Math.round(sixX)+0.5, Math.round(sixY)+0.5, Math.round(sixWidth), Math.round(SIX_YARD_HEIGHT));
  ctx.strokeRect(Math.round(BOX18_LEFT)+0.5, Math.round(goalBottom)+0.5, Math.round(BOX18_WIDTH), Math.round(BOX18_HEIGHT));
  ctx.beginPath(); ctx.moveTo(goalLeft, goalBottom - 1); ctx.lineTo(goalLeft+GOAL_W, goalBottom - 1); ctx.stroke();
  ctx.restore();
}

function drawGoal(){
  ctx.save();
  ctx.lineWidth=4; ctx.strokeStyle='#ffffffbb'; ctx.fillStyle='rgba(255,255,255,0.02)';
  ctx.fillRect(goalLeft,goalTop,GOAL_W,GOAL_H); ctx.strokeRect(goalLeft,goalTop,GOAL_W,GOAL_H);
  ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1;
  for(let i=0;i<=GOAL_W;i+=GOAL_W/7){ ctx.beginPath(); ctx.moveTo(goalLeft+i,goalTop); ctx.lineTo(goalLeft+i,goalBottom); ctx.stroke(); }
  for(let j=0;j<=GOAL_H;j+=GOAL_H/4){ ctx.beginPath(); ctx.moveTo(goalLeft,goalTop+j); ctx.lineTo(goalRight,goalTop+j); ctx.stroke(); }
  ctx.restore();
}

function drawBar(){
  ctx.save();
  // vertical height bar
  ctx.fillStyle='#0b2733'; ctx.fillRect(bar.v.x,bar.v.y,bar.v.w,bar.v.h);
  ctx.strokeStyle='#052f3f'; ctx.strokeRect(bar.v.x,bar.v.y,bar.v.w,bar.v.h);
  const hvY = bar.v.y + (1-hvPos)*(bar.v.h-4);
  ctx.fillStyle = chargingHeight ? '#ffeb3b' : '#9fd6ff';
  ctx.fillRect(bar.v.x+2, hvY, bar.v.w-4, 4);
  if(heightValue!==null){ const lockedY = bar.v.y + (1-heightValue)*(bar.v.h-4); ctx.fillStyle='#ff6b6b'; ctx.fillRect(bar.v.x+1, lockedY-1, bar.v.w-2, 6); }

  // horizontal lateral bar
  ctx.fillStyle='#0b2733'; ctx.fillRect(bar.l.x,bar.l.y,bar.l.w,bar.l.h);
  ctx.strokeStyle='#052f3f'; ctx.strokeRect(bar.l.x,bar.l.y,bar.l.w,bar.l.h);
  const lvX = bar.l.x + lvPos*(bar.l.w-4);
  ctx.fillStyle = chargingLat ? '#ffeb3b' : '#9fd6ff';
  ctx.fillRect(lvX, bar.l.y+2, 4, bar.l.h-4);
  if(latValue!==null){ const lockedX = bar.l.x + latValue*(bar.l.w-4); ctx.fillStyle='#ff6b6b'; ctx.fillRect(lockedX-1, bar.l.y+1, 6, bar.l.h-2); }

  ctx.restore();
}

function drawKeeper(){
  ctx.save();
  ctx.fillStyle='#fbc02d'; ctx.fillRect(Math.round(keeper.x-15), Math.round(keeper.y-10), 30, 30);
  ctx.fillStyle='#f57f17'; ctx.fillRect(Math.round(keeper.x-20), Math.round(keeper.y-8), 5, 20); ctx.fillRect(Math.round(keeper.x+15), Math.round(keeper.y-8), 5, 20);
  ctx.fillStyle='#ffe0bd'; ctx.fillRect(Math.round(keeper.x-10), Math.round(keeper.y-25), 20, 20);
  ctx.fillStyle='#222'; ctx.fillRect(Math.round(keeper.x-10), Math.round(keeper.y-25), 20, 6);
  ctx.fillStyle='#000'; ctx.fillRect(Math.round(keeper.x-6), Math.round(keeper.y-18), 3, 3); ctx.fillRect(Math.round(keeper.x+3), Math.round(keeper.y-18), 3, 3);
  ctx.fillStyle='#d18f6a'; ctx.fillRect(Math.round(keeper.x-1), Math.round(keeper.y-14), 2, 2);
  ctx.fillStyle='#900'; ctx.fillRect(Math.round(keeper.x-4), Math.round(keeper.y-12), 8, 2);
  ctx.fillStyle='#c77f0a'; ctx.fillRect(Math.round(keeper.x-7), Math.round(keeper.y-5), 14, 4);
  ctx.restore();
}

function drawBall(){
  ctx.save(); ctx.translate(ball.x, ball.y);
  const grad = ctx.createRadialGradient(-R_BALL*0.2,-R_BALL*0.2,0,0,0,R_BALL); grad.addColorStop(0,'#ffffff'); grad.addColorStop(1,'#dddddd');
  ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0,0,R_BALL,0,Math.PI*2); ctx.fill();
  ctx.lineWidth = 1.5; ctx.strokeStyle = '#999'; ctx.stroke();
  // classic pentagon pattern (center + 5 around)
  function drawPoly(cx,cy,r,sides,rot,fill,stroke){
    ctx.beginPath(); for(let i=0;i<sides;i++){ const a = rot + i*(2*Math.PI/sides); const x=cx+r*Math.cos(a), y=cy+r*Math.sin(a); if(i===0)ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.closePath();
    if(fill){ ctx.fillStyle = fill; ctx.fill(); } if(stroke){ ctx.lineWidth=1; ctx.strokeStyle=stroke; ctx.stroke(); }
  }
  const centerR = R_BALL * 0.28; drawPoly(0,0,centerR,5,-Math.PI/2,'#000','#fff');
  const outerRadius = R_BALL * 0.62;
  for(let i=0;i<5;i++){ const ang = -Math.PI/2 + i*(2*Math.PI/5); const cx = outerRadius * Math.cos(ang) * 0.92; const cy = outerRadius * Math.sin(ang) * 0.92; drawPoly(cx,cy,centerR*0.9,5,ang+Math.PI/5,'#000','#fff'); }
  ctx.lineWidth = 0.8; ctx.strokeStyle = 'rgba(0,0,0,0.25)'; for(let i=0;i<6;i++){ ctx.beginPath(); const a = i*(2*Math.PI/6); ctx.moveTo(0,0); ctx.lineTo(R_BALL*Math.cos(a)*0.6, R_BALL*Math.sin(a)*0.6); ctx.stroke(); }
  ctx.restore();
}

// -------------------- main loop --------------------
let last=performance.now();
function loop(ts){
  const dt = ts - last; last = ts;

  if(chargingHeight){ const delta = OSC_SPEED*dt/1000; hvPos += delta*hvDir; if(hvPos>1){hvPos=1;hvDir=-1;} if(hvPos<0){hvPos=0;hvDir=1;} }
  if(chargingLat){ const delta = OSC_SPEED*dt/1000; lvPos += delta*lvDir; if(lvPos>1){lvPos=1;lvDir=-1;} if(lvPos<0){lvPos=0;lvDir=1;} }

  if(ball.moving){
    ball.x += ball.vx; ball.y += ball.vy;
    const dx = ball.target.x - ball.x, dy = ball.target.y - ball.y;
    if(Math.abs(dx) < Math.abs(ball.vx) && Math.abs(dy) < Math.abs(ball.vy)){
      ball.x = ball.target.x; ball.y = ball.target.y; ball.moving=false;
      if(circlesOverlap(ball, keeper)){ streak = 0; } else { streak++; high = Math.max(high, streak); }
      updateScore(); setTimeout(resetPositions,700);
    }
  }

  if(keeper.moving){
    keeper.x += keeper.vx; keeper.y += keeper.vy;
    const dx = keeper.target.x - keeper.x, dy = keeper.target.y - keeper.y;
    if(Math.abs(dx) < Math.abs(keeper.vx) && Math.abs(dy) < Math.abs(keeper.vy)){
      keeper.x = keeper.target.x; keeper.y = keeper.target.y; keeper.moving=false;
    }
  }

  ctx.clearRect(0,0,W,H);
  drawBackground(); drawGoal(); drawBar(); drawKeeper(); drawBall();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// -------------------- score helper --------------------
function updateScore(){ streakEl.textContent = streak; highEl.textContent = high; }

// -------------------- mobile / responsive handling --------------------
const touchControlsEl = document.getElementById('touchControls');
const btnHeight = document.getElementById('btn-height');
const btnLat = document.getElementById('btn-lat');
const desktopUI = document.getElementById('desktopUI');

function isTouchDevice(){
  return ( 'ontouchstart' in window ) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || window.matchMedia && window.matchMedia('(pointer:coarse)').matches;
}

// show buttons only on touch devices
function updateTouchUiVisibility(){
  const show = isTouchDevice();
  if(show){
    touchControlsEl.classList.remove('hidden');
    desktopUI.style.display = ''; // keep desktop UI visible beneath, as before
  } else {
    touchControlsEl.classList.add('hidden');
    // you said you don't want buttons on laptop — they are hidden now
  }
}
updateTouchUiVisibility();

// fit canvas for DPR and orientation (makes buttons visible in landscape)
function fitCanvasToDisplay(){
  // container rect where canvas is displayed
  const wrapRect = canvas.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio || 1);

  // Keep internal logical size fixed, but scale backing store by DPR
  canvas.width = LOGICAL_W * dpr;
  canvas.height = LOGICAL_H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // Now handle visual sizing to ensure buttons visible on narrow heights (mobile landscape)
  // If on a touch device and screen is landscape (w>h), cap canvas visual height to 62% of viewport height
  if(isTouchDevice() && window.innerWidth > window.innerHeight){
    // reduce canvas css height (visual) so bottom buttons fit
    const maxVisualHeight = Math.floor(window.innerHeight * 0.62); // tweakable
    canvas.style.height = maxVisualHeight + 'px';
  } else {
    // default: make canvas visual height scale proportionally via width:100% css; clear explicit height
    canvas.style.height = '';
  }

  // store rect for pointer mapping
  canvas._rect = canvas.getBoundingClientRect();
  W = LOGICAL_W; H = LOGICAL_H;
}

// call on resize/orientationchange
window.addEventListener('resize', ()=>{ fitCanvasToDisplay(); updateTouchUiVisibility(); });
window.addEventListener('orientationchange', ()=>{ setTimeout(()=>{ fitCanvasToDisplay(); },120); });

fitCanvasToDisplay();

// -------------------- pointer/touch controls (robust) --------------------
function updateBtnPressed(which, pressed){
  const el = which === 'height' ? btnHeight : btnLat;
  if(pressed){
    el.classList.add('pressed'); el.setAttribute('aria-pressed','true');
  } else {
    el.classList.remove('pressed'); el.setAttribute('aria-pressed','false');
  }
}
function clearButtonVisuals(){
  btnHeight.classList.remove('pressed'); btnLat.classList.remove('pressed');
  btnHeight.setAttribute('aria-pressed','false'); btnLat.setAttribute('aria-pressed','false');
}

// touch start/stop functions (idempotent & safe)
function startHeight(){
  chargingHeight = true; heightValue = null; updateBtnPressed('height', true);
}
function endHeight(){
  chargingHeight = false; updateBtnPressed('height', false);
  heightValue = hvPos;
  tryShoot();
}
function startLat(){
  chargingLat = true; latValue = null; lvDir = -1; lvPos = 1; updateBtnPressed('lat', true);
}
function endLat(){
  chargingLat = false; updateBtnPressed('lat', false);
  latValue = lvPos;
  tryShoot();
}

// pointer events (works for touch, mouse, stylus)
['pointerdown','pointerup','pointercancel','pointerout','pointerleave'].forEach(evt=>{
  btnHeight.addEventListener(evt, e=>{
    e.preventDefault();
    if(evt === 'pointerdown') { btnHeight.setPointerCapture && btnHeight.setPointerCapture(e.pointerId); startHeight(); }
    else { try{ btnHeight.releasePointerCapture && btnHeight.releasePointerCapture(e.pointerId); } catch(_){} endHeight(); }
  });
  btnLat.addEventListener(evt, e=>{
    e.preventDefault();
    if(evt === 'pointerdown') { btnLat.setPointerCapture && btnLat.setPointerCapture(e.pointerId); startLat(); }
    else { try{ btnLat.releasePointerCapture && btnLat.releasePointerCapture(e.pointerId); } catch(_){} endLat(); }
  });
});

// extra fallback for some older browsers
btnHeight.addEventListener('touchstart', e=>{ e.preventDefault(); startHeight(); }, {passive:false});
btnHeight.addEventListener('touchend', e=>{ e.preventDefault(); endHeight(); }, {passive:false});
btnLat.addEventListener('touchstart', e=>{ e.preventDefault(); startLat(); }, {passive:false});
btnLat.addEventListener('touchend', e=>{ e.preventDefault(); endLat(); }, {passive:false});

// keyboard accessibility for buttons
btnHeight.addEventListener('keydown', e=>{ if(e.key==='Enter' || e.key===' ') { startHeight(); }});
btnHeight.addEventListener('keyup', e=>{ if(e.key==='Enter' || e.key===' ') { endHeight(); }});
btnLat.addEventListener('keydown', e=>{ if(e.key==='Enter' || e.key===' ') { startLat(); }});
btnLat.addEventListener('keyup', e=>{ if(e.key==='Enter' || e.key===' ') { endLat(); }});

// when a shot starts we also ensure charging state is cleared to avoid stuck states
const origTryShoot = tryShoot;
tryShoot = function(){
  // clear any stray pointer captures and visuals
  try{ btnHeight.releasePointerCapture && btnHeight.releasePointerCapture(); }catch(e){}
  try{ btnLat.releasePointerCapture && btnLat.releasePointerCapture(); }catch(e){}
  finalizeChargingState();
  clearButtonVisuals();
  origTryShoot();
};

// prevent touch scrolling when touching canvas
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); }, {passive:false});

// -------------------- initial state --------------------
resetPositions();
updateScore();
</script>
</body>
</html>
