<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Penalty Game — Responsive Buttons</title>
<style>
:root{
  --goal-w:175; --goal-h:100; --ball-d:25; --keeper-d:45;
  --btn-min-h-portrait:48px;
  --btn-min-h-landscape:46px;
  --btn-width-portrait:46%;
  --btn-width-landscape:100%;
  --btn-stack-width:120px;
}
html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial;background:#0b1220;color:#eee}
.wrap{display:flex;gap:12px;padding:12px;align-items:flex-start}
.game{position:relative;flex:1;max-width:1100px}
canvas{display:block;border-radius:6px;width:100%;height:auto;background:#000}
.ui{width:260px;min-width:220px}
.panel{background:#071726;padding:12px;border-radius:8px}
h3{margin:6px 0 10px 0;font-weight:600}
.score{font-size:18px;margin-bottom:10px}
.hint{font-size:13px;color:#cfe9ff}

/* touch controls base */
.touch-controls{
  position:absolute;
  left:12px; right:12px; bottom:12px;
  display:flex; justify-content:space-between; pointer-events:none;
  gap:8px;
  padding:0;
  transition:opacity .12s ease, transform .12s ease;
}
.touch-controls.hidden{opacity:0;pointer-events:none;visibility:hidden}
.touch-btn{
  pointer-events:auto;
  user-select:none;
  -webkit-user-select:none;
  display:flex;
  align-items:center;
  justify-content:center;
  background:rgba(11,39,51,0.92);
  border-radius:10px;
  color:#cfe9ff;
  font-weight:700;
  box-shadow:0 6px 18px rgba(0,0,0,0.5);
  border:2px solid rgba(5,47,63,0.6);
  transition:transform .06s ease,opacity .06s;
  touch-action: none;
  -webkit-tap-highlight-color: transparent;
}

/* Portrait (default) — smaller buttons */
.touch-controls.portrait .touch-btn{
  width:var(--btn-width-portrait);
  min-height:var(--btn-min-h-portrait);
  font-size:16px;
}

/* Landscape — stack on the right side */
.touch-controls.landscape{
  left:auto; right:12px; top:12px; bottom:12px;
  width:var(--btn-stack-width);
  flex-direction:column;
  justify-content:flex-end;
  align-items:stretch;
  gap:12px;
}
.touch-controls.landscape .touch-btn{
  width:var(--btn-width-landscape);
  min-height:var(--btn-min-h-landscape);
  font-size:15px;
}

/* pressed state */
.touch-btn.pressed{background:#ffd54f;color:#072026}

/* responsive layout fallback for narrow desktops */
@media (max-width:900px){
  .wrap{flex-direction:column;gap:12px}
  .ui{width:100%}
  .game{max-width:100%}
}
</style>
</head>
<body>
<div class="wrap">
  <div class="game" id="gameWrap">
    <canvas id="c" width="760" height="420"></canvas>

    <!-- touch controls overlay -->
    <div class="touch-controls portrait hidden" id="touchControls" aria-hidden="false">
      <div id="btn-height" class="touch-btn" role="button" aria-pressed="false" tabindex="0">Hold ↑ (Height)</div>
      <div id="btn-lat" class="touch-btn" role="button" aria-pressed="false" tabindex="0">Hold ↓ (Direction)</div>
    </div>
  </div>

  <div class="ui" id="desktopUI">
    <div class="panel">
      <h3>Penalty prototype</h3>
      <div class="score">Current streak: <span id="streak">0</span><br>High score: <span id="high">0</span></div>
      <div class="hint">
        Controls:<br>
        Hold <b>↑</b> to set height (release to lock).<br>
        Hold <b>↓</b> to set lateral (release to lock).<br>
        When both locked the ball will shoot automatically.<br>
        <em>On touch devices: press & hold the on-screen buttons.</em>
      </div>
    </div>
  </div>
</div>

<script>
// -------------- core and constants (keeps previous behavior) --------------
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const LOGICAL_W = 760, LOGICAL_H = 420;
canvas.width = LOGICAL_W; canvas.height = LOGICAL_H;
let W = LOGICAL_W, H = LOGICAL_H;

const GOAL_W=175, GOAL_H=100, BALL_D=25, KEEPER_D=45;
const R_BALL=BALL_D/2, R_KEEP=KEEPER_D/2;
const goalX=(W-GOAL_W)/2, goalY=60;
const goalLeft=goalX, goalRight=goalX+GOAL_W, goalTop=goalY, goalBottom=goalY+GOAL_H;

const SIX_YARD_HEIGHT = 40;
const BOX18_HEIGHT = 110;
const BOX18_LEFT = goalLeft - 60;
const BOX18_WIDTH = GOAL_W + 120;
const BAR_L_Y = goalBottom + BOX18_HEIGHT + 8;

const BAR_V_MARGIN = 6;
const BAR_V_WIDTH = 10;
const BAR_V_X = BOX18_LEFT - BAR_V_WIDTH - BAR_V_MARGIN;
const BAR_V_Y = goalBottom;
const BAR_V_H = BOX18_HEIGHT;

const bar={v:{x:BAR_V_X,y:BAR_V_Y,w:BAR_V_WIDTH,h:BAR_V_H},l:{x:goalX,y:BAR_L_Y,w:GOAL_W,h:10}};

// -------------- state --------------
let ball={x:W/2,y:goalBottom+40+R_BALL,r:R_BALL,vx:0,vy:0,moving:false,target:null};
let keeper={x:W/2,y:goalBottom-R_KEEP,r:R_KEEP,vx:0,vy:0,moving:false,target:null};

let chargingHeight=false, chargingLat=false;
let heightValue=null, latValue=null;
let hvDir=1, lvDir=-1, hvPos=0, lvPos=1;
const OSC_SPEED=0.9;

let streak=0, high=0;
const streakEl=document.getElementById('streak');
const highEl=document.getElementById('high');

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function circlesOverlap(a,b){ const dx=a.x-b.x, dy=a.y-b.y, r=a.r+b.r; return dx*dx+dy*dy<=r*r; }
function mapToGoal(nLat,nHeight){
  const x=goalLeft + nLat*(GOAL_W-BALL_D) + R_BALL;
  const y=goalBottom - nHeight*(GOAL_H-BALL_D) - R_BALL;
  return {x,y};
}
function mapKeeperToGoal(){
  const nLat=Math.random(), nHeight=Math.random();
  const x=goalLeft + nLat*(GOAL_W-KEEPER_D) + R_KEEP;
  const y=goalBottom - nHeight*(GOAL_H-KEEPER_D) - R_KEEP;
  return {x,y};
}

// -------------- shoot/reset (fix stuck lock) --------------
function finalizeChargingState(){
  chargingHeight = false;
  chargingLat = false;
}
function clearButtonVisuals(){
  btnHeight.classList.remove('pressed'); btnLat.classList.remove('pressed');
  btnHeight.setAttribute('aria-pressed','false'); btnLat.setAttribute('aria-pressed','false');
}
function tryShoot(){
  if(heightValue!==null && latValue!==null && !ball.moving){
    // finalize charging to avoid stuck states
    finalizeChargingState();
    clearButtonVisuals();

    ball.target = mapToGoal(latValue, heightValue);
    ball.vx = (ball.target.x - ball.x) / 30;
    ball.vy = (ball.target.y - ball.y) / 30;
    ball.moving = true;

    keeper.target = mapKeeperToGoal();
    keeper.vx = (keeper.target.x - keeper.x) / 30;
    keeper.vy = (keeper.target.y - keeper.y) / 30;
    keeper.moving = true;

    heightValue = null; latValue = null;
    hvPos = 0; lvPos = 1;
  }
}
function resetPositions(){
  ball.x=W/2; ball.y=goalBottom+40+R_BALL; ball.vx=0; ball.vy=0; ball.moving=false; ball.target=null;
  keeper.x=W/2; keeper.y=goalBottom-R_KEEP; keeper.vx=0; keeper.vy=0; keeper.moving=false; keeper.target=null;

  finalizeChargingState();
  heightValue = null; latValue = null;
  hvPos = 0; lvPos = 1;

  clearButtonVisuals();
}

// -------------- input (keyboard) --------------
window.addEventListener('keydown', e=>{
  if(e.repeat) return;
  if(e.key==='ArrowUp'){ chargingHeight=true; heightValue=null; updateBtnPressed('height', true); }
  if(e.key==='ArrowDown'){ chargingLat=true; latValue=null; lvDir=-1; lvPos=1; updateBtnPressed('lat', true); }
});
window.addEventListener('keyup', e=>{
  if(e.key==='ArrowUp'){ chargingHeight=false; heightValue=hvPos; updateBtnPressed('height', false); tryShoot(); }
  if(e.key==='ArrowDown'){ chargingLat=false; latValue=lvPos; updateBtnPressed('lat', false); tryShoot(); }
});

// -------------- drawing (same visuals) --------------
const crowdRects = [];
let CROWD_BOTTOM = 0;
(function generateCrowd(){
  const baseTop = 10; const rowHeight = 14; const cellWidth = 9;
  const cols = Math.ceil(W / cellWidth); const rows = 6;
  for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
    const jitterX=(Math.random()*4-2), x=Math.floor(c*cellWidth+(cellWidth-7)/2+jitterX);
    const jitterY=(Math.random()*4-2), y=Math.floor(10 + r*rowHeight + jitterY);
    const w=7,h=12, base=90+Math.floor(Math.random()*80);
    crowdRects.push({x,y,w,h,base});
  }
  CROWD_BOTTOM = 10 + rows*rowHeight + 2;
})();

function drawBackground(){
  ctx.fillStyle = '#0b1220'; ctx.fillRect(0,0,W,H);
  for(const rect of crowdRects){
    const flicker = 0.25 + Math.random()*0.5;
    const col = Math.max(0, Math.min(255, rect.base + Math.floor((Math.random()-0.5)*20)));
    ctx.fillStyle = `rgba(${col},${col},${col},${flicker})`;
    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
  }
  const trackTop = CROWD_BOTTOM; const grassTop = goalBottom;
  if (grassTop > trackTop){
    const trackGrad = ctx.createLinearGradient(0, trackTop, 0, grassTop);
    trackGrad.addColorStop(0,'#8b2e2e'); trackGrad.addColorStop(1,'#b23a2f');
    ctx.fillStyle = trackGrad; ctx.fillRect(0, trackTop, W, grassTop - trackTop);
    ctx.save(); ctx.globalAlpha = 0.06;
    for(let i=0;i<6;i++){ const y = trackTop + (i/6)*(grassTop - trackTop); ctx.fillRect(0,y,W,2); }
    ctx.restore();
  }
  const grassY = goalBottom;
  const grad = ctx.createLinearGradient(0, grassY, 0, H); grad.addColorStop(0,'#2c7a32'); grad.addColorStop(1,'#1e5c24');
  ctx.fillStyle = grad; ctx.fillRect(0, grassY, W, H - grassY);
  ctx.save(); ctx.globalAlpha = 0.06;
  const stripeCount = 6; for(let i=0;i<stripeCount;i++){ const y = grassY + (i/stripeCount) * (H - grassY); ctx.fillRect(0, y, W, 6); }
  ctx.restore();
  drawFieldLines();
}
function drawFieldLines(){
  ctx.save(); ctx.strokeStyle='white'; ctx.lineWidth=3;
  const sixWidth = GOAL_W * 0.5; const sixX = goalLeft + (GOAL_W - sixWidth)/2; const sixY = goalBottom;
  ctx.strokeRect(Math.round(sixX)+0.5, Math.round(sixY)+0.5, Math.round(sixWidth), Math.round(SIX_YARD_HEIGHT));
  ctx.strokeRect(Math.round(BOX18_LEFT)+0.5, Math.round(goalBottom)+0.5, Math.round(BOX18_WIDTH), Math.round(BOX18_HEIGHT));
  ctx.beginPath(); ctx.moveTo(goalLeft, goalBottom - 1); ctx.lineTo(goalLeft+GOAL_W, goalBottom - 1); ctx.stroke();
  ctx.restore();
}
function drawGoal(){
  ctx.save(); ctx.lineWidth=4; ctx.strokeStyle='#ffffffbb'; ctx.fillStyle='rgba(255,255,255,0.02)';
  ctx.fillRect(goalLeft,goalTop,GOAL_W,GOAL_H); ctx.strokeRect(goalLeft,goalTop,GOAL_W,GOAL_H);
  ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1;
  for(let i=0;i<=GOAL_W;i+=GOAL_W/7){ ctx.beginPath(); ctx.moveTo(goalLeft+i,goalTop); ctx.lineTo(goalLeft+i,goalBottom); ctx.stroke(); }
  for(let j=0;j<=GOAL_H;j+=GOAL_H/4){ ctx.beginPath(); ctx.moveTo(goalLeft,goalTop+j); ctx.lineTo(goalRight,goalTop+j); ctx.stroke(); }
  ctx.restore();
}
function drawBar(){
  ctx.save();
  ctx.fillStyle='#0b2733'; ctx.fillRect(bar.v.x,bar.v.y,bar.v.w,bar.v.h);
  ctx.strokeStyle='#052f3f'; ctx.strokeRect(bar.v.x,bar.v.y,bar.v.w,bar.v.h);
  const hvY = bar.v.y + (1-hvPos)*(bar.v.h-4);
  ctx.fillStyle = chargingHeight ? '#ffeb3b' : '#9fd6ff';
  ctx.fillRect(bar.v.x+2, hvY, bar.v.w-4, 4);
  if(heightValue!==null){ const lockedY = bar.v.y + (1-heightValue)*(bar.v.h-4); ctx.fillStyle='#ff6b6b'; ctx.fillRect(bar.v.x+1, lockedY-1, bar.v.w-2, 6); }

  ctx.fillStyle='#0b2733'; ctx.fillRect(bar.l.x,bar.l.y,bar.l.w,bar.l.h);
  ctx.strokeStyle='#052f3f'; ctx.strokeRect(bar.l.x,bar.l.y,bar.l.w,bar.l.h);
  const lvX = bar.l.x + lvPos*(bar.l.w-4);
  ctx.fillStyle = chargingLat ? '#ffeb3b' : '#9fd6ff';
  ctx.fillRect(lvX, bar.l.y+2, 4, bar.l.h-4);
  if(latValue!==null){ const lockedX = bar.l.x + latValue*(bar.l.w-4); ctx.fillStyle='#ff6b6b'; ctx.fillRect(lockedX-1, bar.l.y+1, 6, bar.l.h-2); }
  ctx.restore();
}
function drawKeeper(){
  ctx.save();
  ctx.fillStyle='#fbc02d'; ctx.fillRect(Math.round(keeper.x-15), Math.round(keeper.y-10), 30, 30);
  ctx.fillStyle='#f57f17'; ctx.fillRect(Math.round(keeper.x-20), Math.round(keeper.y-8), 5, 20); ctx.fillRect(Math.round(keeper.x+15), Math.round(keeper.y-8), 5, 20);
  ctx.fillStyle='#ffe0bd'; ctx.fillRect(Math.round(keeper.x-10), Math.round(keeper.y-25), 20, 20);
  ctx.fillStyle='#222'; ctx.fillRect(Math.round(keeper.x-10), Math.round(keeper.y-25), 20, 6);
  ctx.fillStyle='#000'; ctx.fillRect(Math.round(keeper.x-6), Math.round(keeper.y-18), 3, 3); ctx.fillRect(Math.round(keeper.x+3), Math.round(keeper.y-18), 3, 3);
  ctx.fillStyle='#d18f6a'; ctx.fillRect(Math.round(keeper.x-1), Math.round(keeper.y-14), 2, 2);
  ctx.fillStyle='#900'; ctx.fillRect(Math.round(keeper.x-4), Math.round(keeper.y-12), 8, 2);
  ctx.fillStyle='#c77f0a'; ctx.fillRect(Math.round(keeper.x-7), Math.round(keeper.y-5), 14, 4);
  ctx.restore();
}
function drawBall(){
  ctx.save(); ctx.translate(ball.x, ball.y);
  const grad = ctx.createRadialGradient(-R_BALL*0.2,-R_BALL*0.2,0,0,0,R_BALL); grad.addColorStop(0,'#ffffff'); grad.addColorStop(1,'#dddddd');
  ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0,0,R_BALL,0,Math.PI*2); ctx.fill();
  ctx.lineWidth = 1.5; ctx.strokeStyle = '#999'; ctx.stroke();
  function drawPoly(cx,cy,r,sides,rot,fill,stroke){
    ctx.beginPath(); for(let i=0;i<sides;i++){ const a = rot + i*(2*Math.PI/sides); const x=cx+r*Math.cos(a), y=cy+r*Math.sin(a); if(i===0)ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.closePath();
    if(fill){ ctx.fillStyle = fill; ctx.fill(); } if(stroke){ ctx.lineWidth=1; ctx.strokeStyle=stroke; ctx.stroke(); }
  }
  const centerR = R_BALL * 0.28; drawPoly(0,0,centerR,5,-Math.PI/2,'#000','#fff');
  const outerRadius = R_BALL * 0.62;
  for(let i=0;i<5;i++){ const ang = -Math.PI/2 + i*(2*Math.PI/5); const cx = outerRadius * Math.cos(ang) * 0.92; const cy = outerRadius * Math.sin(ang) * 0.92; drawPoly(cx,cy,centerR*0.9,5,ang+Math.PI/5,'#000','#fff'); }
  ctx.lineWidth = 0.8; ctx.strokeStyle = 'rgba(0,0,0,0.25)'; for(let i=0;i<6;i++){ ctx.beginPath(); const a = i*(2*Math.PI/6); ctx.moveTo(0,0); ctx.lineTo(R_BALL*Math.cos(a)*0.6, R_BALL*Math.sin(a)*0.6); ctx.stroke(); }
  ctx.restore();
}

// -------------- game loop --------------
let last=performance.now();
function loop(ts){
  const dt = ts - last; last = ts;
  if(chargingHeight){ const delta = OSC_SPEED*dt/1000; hvPos += delta*hvDir; if(hvPos>1){hvPos=1;hvDir=-1;} if(hvPos<0){hvPos=0;hvDir=1;} }
  if(chargingLat){ const delta = OSC_SPEED*dt/1000; lvPos += delta*lvDir; if(lvPos>1){lvPos=1;lvDir=-1;} if(lvPos<0){lvPos=0;lvDir=1;} }

  if(ball.moving){
    ball.x += ball.vx; ball.y += ball.vy;
    const dx = ball.target.x - ball.x, dy = ball.target.y - ball.y;
    if(Math.abs(dx) < Math.abs(ball.vx) && Math.abs(dy) < Math.abs(ball.vy)){
      ball.x = ball.target.x; ball.y = ball.target.y; ball.moving=false;
      if(circlesOverlap(ball, keeper)){ streak = 0; } else { streak++; high = Math.max(high, streak); }
      updateScore(); setTimeout(resetPositions,700);
    }
  }

  if(keeper.moving){
    keeper.x += keeper.vx; keeper.y += keeper.vy;
    const dx = keeper.target.x - keeper.x, dy = keeper.target.y - keeper.y;
    if(Math.abs(dx) < Math.abs(keeper.vx) && Math.abs(dy) < Math.abs(keeper.vy)){
      keeper.x = keeper.target.x; keeper.y = keeper.target.y; keeper.moving=false;
    }
  }

  ctx.clearRect(0,0,W,H);
  drawBackground(); drawGoal(); drawBar(); drawKeeper(); drawBall();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// -------------- score helper --------------
function updateScore(){ streakEl.textContent = streak; highEl.textContent = high; }

// -------------- touch UI logic & responsiveness --------------
const touchControlsEl = document.getElementById('touchControls');
const btnHeight = document.getElementById('btn-height');
const btnLat = document.getElementById('btn-lat');
const desktopUI = document.getElementById('desktopUI');

function isTouchDevice(){
  return ( 'ontouchstart' in window ) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || window.matchMedia && window.matchMedia('(pointer:coarse)').matches;
}

function updateTouchUiVisibility(){
  const show = isTouchDevice();
  if(show){
    touchControlsEl.classList.remove('hidden');
  } else {
    touchControlsEl.classList.add('hidden');
  }
}
updateTouchUiVisibility();

function updateOrientationClass(){
  const isLandscape = window.innerWidth > window.innerHeight;
  if(isTouchDevice() && isLandscape){
    touchControlsEl.classList.remove('portrait'); touchControlsEl.classList.add('landscape');
    // shrink canvas visual height so buttons fit vertically
    const maxVisualHeight = Math.floor(window.innerHeight * 0.62);
    canvas.style.height = maxVisualHeight + 'px';
  } else {
    touchControlsEl.classList.remove('landscape'); touchControlsEl.classList.add('portrait');
    // portrait: reset CSS height so canvas scales by width
    canvas.style.height = '';
  }
  // update stored rect for pointer mapping
  canvas._rect = canvas.getBoundingClientRect();
}

// DPR & fitting
function fitCanvasToDisplay(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = LOGICAL_W * dpr;
  canvas.height = LOGICAL_H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  canvas._rect = canvas.getBoundingClientRect();
  W = LOGICAL_W; H = LOGICAL_H;
  updateOrientationClass();
}

window.addEventListener('resize', ()=>{ fitCanvasToDisplay(); updateTouchUiVisibility(); });
window.addEventListener('orientationchange', ()=>{ setTimeout(()=>{ fitCanvasToDisplay(); },120); });

fitCanvasToDisplay();

// -------------- pointer/touch handling (robust) --------------
function updateBtnPressed(which, pressed){
  const el = which === 'height' ? btnHeight : btnLat;
  if(pressed){ el.classList.add('pressed'); el.setAttribute('aria-pressed','true'); }
  else { el.classList.remove('pressed'); el.setAttribute('aria-pressed','false'); }
}

function startHeight(){ chargingHeight = true; heightValue = null; updateBtnPressed('height', true); }
function endHeight(){ chargingHeight = false; updateBtnPressed('height', false); heightValue = hvPos; tryShoot(); }
function startLat(){ chargingLat = true; latValue = null; lvDir = -1; lvPos = 1; updateBtnPressed('lat', true); }
function endLat(){ chargingLat = false; updateBtnPressed('lat', false); latValue = lvPos; tryShoot(); }

// pointer events for both buttons
['pointerdown','pointerup','pointercancel','pointerout','pointerleave'].forEach(evt=>{
  btnHeight.addEventListener(evt, e=>{
    e.preventDefault();
    if(evt === 'pointerdown'){ btnHeight.setPointerCapture && btnHeight.setPointerCapture(e.pointerId); startHeight(); }
    else { try{ btnHeight.releasePointerCapture && btnHeight.releasePointerCapture(e.pointerId); }catch(_{}); endHeight(); }
  });
  btnLat.addEventListener(evt, e=>{
    e.preventDefault();
    if(evt === 'pointerdown'){ btnLat.setPointerCapture && btnLat.setPointerCapture(e.pointerId); startLat(); }
    else { try{ btnLat.releasePointerCapture && btnLat.releasePointerCapture(e.pointerId); }catch(_{}); endLat(); }
  });
});

// fallback for older devices
btnHeight.addEventListener('touchstart', e=>{ e.preventDefault(); startHeight(); }, {passive:false});
btnHeight.addEventListener('touchend', e=>{ e.preventDefault(); endHeight(); }, {passive:false});
btnLat.addEventListener('touchstart', e=>{ e.preventDefault(); startLat(); }, {passive:false});
btnLat.addEventListener('touchend', e=>{ e.preventDefault(); endLat(); }, {passive:false});

// keyboard accessibility
btnHeight.addEventListener('keydown', e=>{ if(e.key==='Enter' || e.key===' ') startHeight(); });
btnHeight.addEventListener('keyup', e=>{ if(e.key==='Enter' || e.key===' ') endHeight(); });
btnLat.addEventListener('keydown', e=>{ if(e.key==='Enter' || e.key===' ') startLat(); });
btnLat.addEventListener('keyup', e=>{ if(e.key==='Enter' || e.key===' ') endLat(); });

// prevent scrolling while touching canvas
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); }, {passive:false});

// ensure no stuck charging on page focus/blur
window.addEventListener('blur', ()=>{ finalizeChargingState(); clearButtonVisuals(); });
window.addEventListener('visibilitychange', ()=>{ if(document.hidden){ finalizeChargingState(); clearButtonVisuals(); } });

// final init
resetPositions(); updateScore();

</script>
</body>
</html>
